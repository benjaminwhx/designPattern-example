# 行为型模式
共分为11种：
* 策略模式
* 模板方法模式
* 观察者模式
* 迭代子模式
* 责任链模式
* 命令模式
* 备忘录模式
* 状态模式
* 访问者模式
* 中介者模式
* 解释器模式

## 1、策略模式
### 1.1、策略模式的重心
策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的灵活性和扩展性。

### 1.2、算法的平等性
策略模式的一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。
所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。
所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。

### 1.3、运行时策略的唯一性
运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

### 1.4、公有的行为
经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须用Java抽象
类实现，而不能使用接口。这其实也是典型的将代码向继承等级结构的上方集中的标准做法。

## 2、模板方法模式
### 2.1、模板方法模式的优点及适用场景
容易扩展，一般来说，抽象类中的模板方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。
便于维护。对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。
比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。
在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式

## 3、观察者模式
观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。

使用观察者模式的好处：

1. 支持简单的广播通信，自动通知所有已经订阅过的对象。
2. 页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。
3. 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。

## 4、迭代子模式
迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序的访问一个聚集中的元素而不必暴露聚集的内部表象(internal representation)。
i1包里放的是个人的例子，i2包里放的是参考mybatis写的一个根据表达式读取对象属性的工具类。

更多描述可以参考博客：https://www.jianshu.com/p/a0f1ac801e61 以及 https://segmentfault.com/a/1190000014881064?utm_source=tag-newest

