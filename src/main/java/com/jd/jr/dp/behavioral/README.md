# 行为型模式
共分为11种：
* 策略模式
* 模板方法模式
* 观察者模式
* 迭代子模式
* 责任链模式
* 命令模式
* 备忘录模式
* 状态模式
* 访问者模式
* 中介者模式
* 解释器模式

## 1、策略模式
### 1.1、策略模式的重心
策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的灵活性和扩展性。

### 1.2、算法的平等性
策略模式的一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。
所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。
所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。

### 1.3、运行时策略的唯一性
运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

### 1.4、公有的行为
经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须用Java抽象
类实现，而不能使用接口。这其实也是典型的将代码向继承等级结构的上方集中的标准做法。

## 2、模板方法模式
### 2.1、模板方法模式的优点及适用场景
容易扩展，一般来说，抽象类中的模板方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。
便于维护。对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。
比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。
在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式

## 3、观察者模式
观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。

使用观察者模式的好处：

1. 支持简单的广播通信，自动通知所有已经订阅过的对象。
2. 页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。
3. 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。

## 4、迭代子模式
迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序的访问一个聚集中的元素而不必暴露聚集的内部表象(internal representation)。
i1包里放的是个人的例子，i2包里放的是参考mybatis写的一个根据表达式读取对象属性的工具类。

更多描述可以参考博客：https://www.jianshu.com/p/a0f1ac801e61 以及 https://segmentfault.com/a/1190000014881064?utm_source=tag-newest

## 5、责任链模式
责任链模式是一条链，链上有多个节点，每个节点都有各自的责任。当有输入时，第一个责任节点看自己能否处理该输入，如果可以就处理。如果不能就交由下一个责任节点处理。依次类推，直到最后一个责任节点。
典型的应用场景：
1. 一个请求需要一系列的处理工作。
2. 业务流的处理，例如文件审批。
3. 对系统进行扩展补充。

## 6、命令模式
命令模式主要应用于将行为调用者与实现者解耦。比如我们以前惯用的写代码的方式是LogicProcess logic = new LogicProcess(); 然后紧接着调用实现方法logic.process()，这种写法其实非常普遍，但这种写法把行为调用者和行为实现者耦合在了一起，一般情况下并没有什么问题的，但当调用逻辑比较复杂或则调用行为有多种实现时就非常不利于程序的扩展。

命令模式的适用场景描述：
1. 整个调用过程比较繁杂，或者存在多处这种调用。使用Command类对该调用加以封装，便于功能的再利用。
2. 调用前后需要对调用参数进行某些处理。
3. 调用前后需要进行某些额外处理，比如日志，缓存，记录历史操作等。

博文参考：
1. https://blog.csdn.net/zhwyj1019/article/details/79758057
2. https://blog.51cto.com/bolaven/1368935
3. https://www.cnblogs.com/lfxiao/p/6825644.html

## 7、备忘录模式
备忘录模式的主要优点如下：
1. 它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。
2. 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。

备忘录模式的主要缺点如下：
1. 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。

适用场景：
1. 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。
2. 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。

## 8、状态模式
把所有动作都封装在状态对象中，状态持有者将行为委托给当前状态对象。也就是说，状态持有者（比如汽车，电视，ATM机都有多个状态）并不知道动作细节，状态持有者只关心自己当前所处的状态（持有的状态对象是哪个），再把一切事情都交给当前状态对象去打理就好了，甚至都不用去控制状态切换（当然，状态持有者有权利控制状态切换，也可以选择做甩手掌柜。。）

http://www.ayqy.net/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88state-pattern%EF%BC%89/

## 9、访问者模式

## 10、中介者模式
中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。

https://blog.csdn.net/wwwdc1012/article/details/83389158

## 11、解释器模式
解释器模式在软件开发中应用比较少，它主要应用在底层的编程语言设计上，因此不太容易理解。解释器模式很好的将数据的解析与使用分离开，如果不采用解释器模式，当客户端需要对一些字符进行解析时，就会直接编写解析的方法，造成数据之间的耦合，当有其他地方也需要同样的解析时，就不能很好地产生复用，这不符合面向对象的设计原则，不能达到代码的最大复用性，而采用解释器模式后，从解释器的原理上就迫使开发人员一定要考虑代码的复用性。